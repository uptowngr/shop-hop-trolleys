<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Trolley Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .trolley-icon {
      font-size: 22px;
      text-align: center;
      line-height: 24px;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid white;
      box-shadow: 0 0 4px rgba(0,0,0,0.4);
    }
    .trolley-red {
      background-color: #dc2626; /* red */
      color: #ffffff;
    }
    .trolley-green {
      background-color: #16a34a; /* green */
      color: #ffffff;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ðŸ” Optimus API settings
    const API_URL = 'https://api3p.optimustracking.com/v1/clients/5540/position/latest';
    const API_KEY = 'ef5cc554-ab98-4719-9a28-e919ba8558f2'; // update here if you regenerate the key

    // ðŸ‘‰ Map deviceId -> label + line color
    // Fill these in once you know which deviceId is which trolley.
    // Example (adjust the numbers to match your real deviceIds):
    const DEVICE_CONFIG = {
      // 525217: { label: 'Red Line 1', line: 'red' },
      // 111111: { label: 'Red Line 2', line: 'red' },
      // 222222: { label: 'Green Line 1', line: 'green' },
      // 333333: { label: 'Green Line 2', line: 'green' },
      // 444444: { label: 'Green Line 3', line: 'green' }
    };

    // Start roughly where the first tracker pinged
    const map = L.map('map').setView([42.958852, -85.646653], 14);

    // ðŸ—ºï¸ Nicer free tiles: Carto Voyager
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap &copy; CARTO'
    }).addTo(map);

    // Red + green trolley icons
    const redTrolleyIcon = L.divIcon({
      className: 'trolley-icon trolley-red',
      html: 'ðŸšŒ',
      iconSize: [28, 28],
      iconAnchor: [14, 14]
    });

    const greenTrolleyIcon = L.divIcon({
      className: 'trolley-icon trolley-green',
      html: 'ðŸšŒ',
      iconSize: [28, 28],
      iconAnchor: [14, 14]
    });

    const markers = {}; // deviceId -> Leaflet marker
    let firstFit = true;

    function getConfigForDevice(id) {
      const cfg = DEVICE_CONFIG[id];
      if (cfg) return cfg;
      // Default if not configured yet
      return { label: 'Device ' + id, line: 'red' }; // default red if unknown
    }

    function getIconForLine(line) {
      return line === 'green' ? greenTrolleyIcon : redTrolleyIcon;
    }

    async function fetchPositions() {
      try {
        const res = await fetch(API_URL, {
          headers: {
            'accept': 'application/json',
            'api-key': API_KEY
          }
        });

        if (!res.ok) {
          console.error('API error:', res.status, res.statusText);
          return;
        }

        const data = await res.json();
        const points = [];

        data.forEach(pos => {
          const id = pos.deviceId;
          const lat = Number(pos.latitude);
          const lng = Number(pos.longitude);

          if (Number.isNaN(lat) || Number.isNaN(lng)) return;

          const cfg = getConfigForDevice(id);
          const label = cfg.label;
          const icon = getIconForLine(cfg.line);

          const popupHtml =
            `<strong>${label}</strong><br>` +
            `Lat: ${lat.toFixed(5)}, Lng: ${lng.toFixed(5)}<br>` +
            (pos.battery ? `Battery: ${Number(pos.battery).toFixed(0)}%<br>` : '') +
            (pos.utcDate ? `Last update: ${pos.utcDate}` : '');

          if (!markers[id]) {
            markers[id] = L.marker([lat, lng], { icon })
              .addTo(map)
              .bindPopup(popupHtml);
          } else {
            markers[id].setLatLng([lat, lng]);
            markers[id].setIcon(icon);
            markers[id].setPopupContent(popupHtml);
          }

          points.push([lat, lng]);
        });

        if (firstFit && points.length > 0) {
          const bounds = L.latLngBounds(points);
          map.fitBounds(bounds, { padding: [40, 40] });
          firstFit = false;
        }
      } catch (err) {
        console.error('Fetch error:', err);
      }
    }

    // Initial fetch + refresh every 10 seconds (live view)
    fetchPositions();
    setInterval(fetchPositions, 10000);
  </script>
</body>
</html>
